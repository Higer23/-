// dataCollector.js
const NA = "N/A";

const cyrb53 = (str, seed = 0) => {
    let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
    for (let i = 0, ch; i < str.length; i++) {
        ch = str.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
    h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
    return 4294967296 * (2097151 & h2) + (h1 >>> 0);
};

// --- ADVANCED DATA COLLECTION FUNCTIONS ---

const getFingerprints = async () => {
    const getCanvasFp = () => { try { const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); const txt = 'abcdefghijklmnopqrstuvwxyz0123456789'; ctx.textBaseline = "top"; ctx.font = "14px 'Arial'"; ctx.textBaseline = "alphabetic"; ctx.fillStyle = "#f60"; ctx.fillRect(125, 1, 62, 20); ctx.fillStyle = "#069"; ctx.fillText(txt, 2, 15); ctx.fillStyle = "rgba(102, 204, 0, 0.7)"; ctx.fillText(txt, 4, 17); return cyrb53(canvas.toDataURL()); } catch (e) { return NA; } };
    const getAudioFp = async () => { try { const audioCtx = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 44100, 44100); const oscillator = audioCtx.createOscillator(); oscillator.type = "triangle"; oscillator.frequency.setValueAtTime(10000, audioCtx.currentTime); const compressor = audioCtx.createDynamicsCompressor(); compressor.threshold.setValueAtTime(-50, audioCtx.currentTime); oscillator.connect(compressor); compressor.connect(audioCtx.destination); oscillator.start(0); const renderedBuffer = await audioCtx.startRendering(); const fingerprint = renderedBuffer.getChannelData(0).slice(4500, 5000).reduce((acc, val) => acc + Math.abs(val), 0).toString(); return cyrb53(fingerprint); } catch (e) { return NA; } };
    const getFontsFp = () => { try { const baseFonts = ['monospace', 'sans-serif', 'serif']; const testString = "mmmmmmmmmmlli"; const testSize = '72px'; const h = document.body; const s = document.createElement("span"); s.style.fontSize = testSize; s.innerHTML = testString; const defaultWidth = {}; const defaultHeight = {}; baseFonts.forEach(font => { s.style.fontFamily = font; h.appendChild(s); defaultWidth[font] = s.offsetWidth; defaultHeight[font] = s.offsetHeight; h.removeChild(s); }); const fontList = ['Arial', 'Verdana', 'Helvetica', 'Times New Roman', 'Courier New', 'Georgia', 'Palatino', 'Garamond', 'Bookman', 'Comic Sans MS', 'Trebuchet MS', 'Arial Black', 'Impact']; let availableFonts = fontList.filter(font => baseFonts.some(baseFont => { s.style.fontFamily = `${font},${baseFont}`; h.appendChild(s); const detected = s.offsetWidth !== defaultWidth[baseFont] || s.offsetHeight !== defaultHeight[baseFont]; h.removeChild(s); return detected; })); return cyrb53(availableFonts.join(',')); } catch (e) { return NA; } };
    const [audio_fingerprint, canvas_fingerprint, fonts_hash] = await Promise.all([ getAudioFp(), getCanvasFp(), getFontsFp() ]);
    return { audio_fingerprint, canvas_fingerprint, fonts_hash };
};
const getGeolocationInfo = () => new Promise(resolve => { const fetchIpApi = async () => { try { const response = await fetch(`https://ip-api.com/json/?fields=status,message,country,countryCode,region,regionName,city,zip,lat,lon,timezone,isp,org,as,query`); if (!response.ok) return { query: NA, status: 'fail', message: `HTTP error ${response.status}` }; return await response.json(); } catch (e) { return { query: NA, status: 'fail', message: 'Network request failed' }; } }; if (!navigator.geolocation) return resolve({ ip: NA, geolocation: "API Not Supported" }); navigator.geolocation.getCurrentPosition( async pos => { const ipApiData = await fetchIpApi(); const fullGeoData = { PERMISSION: 'Granted', GPS_COORDS: { lat: pos.coords.latitude, lon: pos.coords.longitude, acc: pos.coords.accuracy }, IP_API_DATA: ipApiData }; resolve({ ip: ipApiData.query, geolocation: JSON.stringify(fullGeoData, null, 2) }); }, async err => { const ipApiData = await fetchIpApi(); const fullGeoData = { PERMISSION: err.code === 1 ? 'Denied by user' : 'Unavailable', IP_API_DATA: ipApiData }; resolve({ ip: ipApiData.query, geolocation: JSON.stringify(fullGeoData, null, 2) }); }, { timeout: 10000, enableHighAccuracy: true } ); });
const getSystemInfo = async () => { const ua = navigator.userAgent || ''; let os = NA, browser = NA, engine = NA; if (/Windows/.test(ua)) os = "Windows"; else if (/Macintosh/.test(ua)) os = "macOS"; else if (/Linux/.test(ua)) os = "Linux"; else if (/Android/.test(ua)) os = "Android"; else if (/iPhone|iPad|iPod/.test(ua)) os = "iOS"; const edgeMatch = ua.match(/Edg\/([\d.]+)/); const firefoxMatch = ua.match(/Firefox\/([\d.]+)/); const chromeMatch = ua.match(/Chrome\/([\d.]+)/); const safariMatch = ua.match(/Version\/([\d.]+).*Safari/); if (edgeMatch) { browser = `Edge ${edgeMatch[1]}`; engine = 'Blink'; } else if (chromeMatch) { browser = `Chrome ${chromeMatch[1]}`; engine = 'Blink'; } else if (firefoxMatch) { browser = `Firefox ${firefoxMatch[1]}`; engine = 'Gecko'; } else if (safariMatch) { browser = `Safari ${safariMatch[1]}`; engine = 'WebKit'; } let gpu = NA; try { const canvas = document.createElement('canvas'); const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl'); if (gl) { const ext = gl.getExtension('WEBGL_debug_renderer_info'); gpu = ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : 'Could not get extension'; } } catch(e) { gpu = 'Error getting GPU'; } let uad = { platform: NA, mobile: NA, brand: NA, model: NA }; if (navigator.userAgentData && typeof navigator.userAgentData.getHighEntropyValues === 'function') { try { Object.assign(uad, await navigator.userAgentData.getHighEntropyValues(["platform", "model", "brand", "uaFullVersion"])); } catch(e) { console.warn("Could not get high entropy values:", e); } } const conn = navigator.connection || null; return { os: `${os} (${uad.platform || navigator.platform || NA})`, device_platform: navigator.platform || NA, browser, browser_engine: engine, user_agent: ua, gpu_info: gpu, cpu_cores: navigator.hardwareConcurrency || NA, ram_gb: navigator.deviceMemory ? `${navigator.deviceMemory} GB` : NA, plugins_list: (navigator.plugins ? Array.from(navigator.plugins) : []).map(p => p.name).join(', ') || NA, network_info: conn ? `${conn.effectiveType || NA}, Downlink: ${conn.downlink || NA} Mbps` : NA, user_agent_data: JSON.stringify(uad, null, 2), device_brand: uad.brand || NA, device_model: uad.model || NA }; };
const getBehavioralInfo = () => { const s = window.screen; const gcd = (a, b) => b ? gcd(b, a % b) : a; const r = gcd(s.width, s.height); return { screen_resolution: `${s.width}x${s.height}`, aspect_ratio: `${s.width/r}:${s.height/r}`, color_pixel_depth: `${s.colorDepth} bit / ${s.pixelDepth} bit`, screen_orientation: s.orientation ? s.orientation.type : NA, navigator_languages: navigator.languages ? navigator.languages.join(', ') : NA, keyboard_layout: navigator.keyboard ? 'API Supported' : 'API Not Supported', do_not_track: navigator.doNotTrack || 'Not Specified', pointer_support: window.matchMedia('(pointer: fine)').matches ? 'Mouse/Fine' : 'Coarse/Touch', touch_capable: 'ontouchstart' in window || navigator.maxTouchPoints > 0 ? "Yes" : "No", history_length: history.length, device_type: /Mobi/i.test(navigator.userAgent) ? 'Mobile' : 'Desktop/Tablet' }; };
const getMiscInfo = async () => { let battery_status = NA, battery_charge_discharge_time = NA; if (navigator.getBattery && typeof navigator.getBattery === 'function') { try { const battery = await navigator.getBattery(); battery_status = `${Math.round(battery.level*100)}% (${battery.charging ? 'Charging' : 'Not Charging'})`; const chargeTime = isFinite(battery.chargingTime) ? `${battery.chargingTime/60}min` : NA; const dischargeTime = isFinite(battery.dischargingTime) ? `${battery.dischargingTime/60}min` : NA; battery_charge_discharge_time = `Charge: ${chargeTime}, Discharge: ${dischargeTime}`; } catch(e) { /* ignore */ } } const adblock = await (async () => { try { await fetch("https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js", { method: 'HEAD', mode: 'no-cors', cache: 'no-store' }); return "No"; } catch (error) { return "Yes"; } })(); const apis = { 'WebUSB': !!navigator.usb, 'WebBluetooth': !!navigator.bluetooth, 'WebXR': !!navigator.xr, 'Gamepad': !!navigator.getGamepads, 'WebRTC': !!window.RTCPeerConnection, 'WebAudio': !!(window.AudioContext || window.webkitAudioContext) }; const advanced_api_support = Object.entries(apis).filter(([_,v]) => v).map(([k,_]) => k).join(', ') || NA; return { battery_status, battery_charge_discharge_time, adblock_detected: adblock, sensor_support: ('DeviceMotionEvent' in window) ? 'Yes' : 'No/Unknown', advanced_api_support, referrer: document.referrer || "Direct Entry" }; };

/**
 * Runs all data collection functions and returns a single object.
 * @param {Date} startTime - The start time of the visit.
 * @returns {Object} - An object containing all collected data.
 */
export const collectAllData = async (startTime) => {
    const promises = [getGeolocationInfo(), getFingerprints(), getSystemInfo(), getBehavioralInfo(), getMiscInfo()];
    const results = await Promise.allSettled(promises);
    const allData = results.reduce((acc, r) => (r.status === 'fulfilled' && r.value) ? { ...acc, ...r.value } : acc, {});
    
    allData.timestamp = new Date().toISOString();
    allData.visit_duration = `${((new Date() - startTime) / 1000).toFixed(2)} seconds`;

    const templateKeys = ['timestamp', 'visitor_name', 'ip', 'geolocation', 'canvas_fingerprint', 'audio_fingerprint', 'fonts_hash', 'device_type', 'device_brand', 'device_model', 'gpu_info', 'cpu_cores', 'ram_gb', 'battery_status', 'battery_charge_discharge_time', 'screen_resolution', 'aspect_ratio', 'color_pixel_depth', 'screen_orientation', 'sensor_support', 'os', 'device_platform', 'browser', 'browser_engine', 'user_agent', 'plugins_list', 'referrer', 'network_info', 'navigator_languages', 'keyboard_layout', 'adblock_detected', 'do_not_track', 'pointer_support', 'touch_capable', 'history_length', 'visit_duration', 'user_agent_data', 'advanced_api_support'];
    templateKeys.forEach(key => { if (!allData[key]) allData[key] = NA; });

    return allData;
};
